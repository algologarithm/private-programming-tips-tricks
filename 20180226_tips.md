2018年2月26日
=============
##  未来并非来自上天的赠与，而要靠自己不懈地寻找。
![](nier3.jpg)

1.  赋值运算符为什么要返回引用？


    答：因为赋值操作会改变左值，而 + 之类的运算符不会改变操作数，所以说赋值运算符重载要返回引用以用于类似 (a=b)=c 这样的再次对a=b进行写操作的表达式。+ 返回一个临时对象是合情合理的 ，你若返回引用大多数情况下也不会出错或导致某个操作数被意外修改，但这就使(a+b)=c这样的表达式可以出现，这就有点不符合约定了，当然，你也可以让 + 返回一个常引用。
    
2.  +   赋值，下标，调用，和成员访问箭头必须是类的成员
    +   复合赋值运算符一般是成员
    +   改变对象状态的运算符或者与给定类型密切相关的运算符，如递增递减与解引用运算符，应该是成员
    +   具有对称性的运算符可能转换任意一端的运算对象，如算术，相等性，关系和位运算符等，因此一般为普通非成员函数。
    +   如果希望为类自定义IO运算符，则必须定义成非成员函数。当然，IO运算符通常需要读写类的非公有数据成员，所以IO运算符一般声明为友元。
    
3.  关于inline:

    在c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数。
    
    栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。
    
    在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。
    
    定义在类中的成员函数缺省都是内联的，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的。
    
4.  文件流的状态判别:

        # is_open()：判定流对象是否与一个打开的文件相联系，若是，返回true，否则返回false

        # good()：刚进行的操作成功时返回true，否则返回false

        # fail()：与good()相反，刚进行的操作失败时返回true，否则返回false

        # bad()：如果进行了非法操作返回true，否则返回false

        # eof()：进行输入操作时，若到达文件尾返回true，否则返回false